"use strict";

const {
  errors
} = require('../errors');
<<<<<<< HEAD

=======
>>>>>>> branch-teste-codigo
/**
 * Throws an error with "details" property from
 * "errors" object.
 * @param {Object} details - Error details
 */
<<<<<<< HEAD
const throwInvalidOptionError = details => {
  if (!details) {
    details = errors.unknownError;
  }

  // throw this error synchronously, it will be caught later on and
  // the details will be propagated to the promise chain
=======


const throwInvalidOptionError = details => {
  if (!details) {
    details = errors.unknownError;
  } // throw this error synchronously, it will be caught later on and
  // the details will be propagated to the promise chain


>>>>>>> branch-teste-codigo
  const err = new Error();
  err.details = details;
  throw err;
};
<<<<<<< HEAD

=======
>>>>>>> branch-teste-codigo
/**
 * Selects exec args based on the configured `testingType`
 * @param {string} testingType The type of tests being executed
 * @returns {string[]} The array of new exec arguments
 */
<<<<<<< HEAD
=======


>>>>>>> branch-teste-codigo
const processTestingType = options => {
  if (options.e2e && options.component) {
    return throwInvalidOptionError(errors.incompatibleTestTypeFlags);
  }
<<<<<<< HEAD
  if (options.testingType && (options.component || options.e2e)) {
    return throwInvalidOptionError(errors.incompatibleTestTypeFlags);
  }
  if (options.testingType === 'component' || options.component || options.ct) {
    return ['--testing-type', 'component'];
  }
  if (options.testingType === 'e2e' || options.e2e) {
    return ['--testing-type', 'e2e'];
  }
  if (options.testingType) {
    return throwInvalidOptionError(errors.invalidTestingType);
  }
  return [];
};

=======

  if (options.testingType && (options.component || options.e2e)) {
    return throwInvalidOptionError(errors.incompatibleTestTypeFlags);
  }

  if (options.testingType === 'component' || options.component || options.ct) {
    return ['--testing-type', 'component'];
  }

  if (options.testingType === 'e2e' || options.e2e) {
    return ['--testing-type', 'e2e'];
  }

  if (options.testingType) {
    return throwInvalidOptionError(errors.invalidTestingType);
  }

  return [];
};
>>>>>>> branch-teste-codigo
/**
 * Throws an error if configFile is string 'false' or boolean false
 * @param {*} options
 */
<<<<<<< HEAD
=======


>>>>>>> branch-teste-codigo
const checkConfigFile = options => {
  // CLI will parse as string, module API can pass in boolean
  if (options.configFile === 'false' || options.configFile === false) {
    throwInvalidOptionError(errors.invalidConfigFile);
  }
};
<<<<<<< HEAD
=======

>>>>>>> branch-teste-codigo
module.exports = {
  throwInvalidOptionError,
  processTestingType,
  checkConfigFile
};