"use strict";

const _ = require('lodash');
<<<<<<< HEAD
const os = require('os');
const path = require('path');
const untildify = require('untildify');
const debug = require('debug')('cypress:cli');
const fs = require('../fs');
const util = require('../util');
const getPlatformExecutable = () => {
  const platform = os.platform();
  switch (platform) {
    case 'darwin':
      return 'Contents/MacOS/Cypress';
    case 'linux':
      return 'Cypress';
    case 'win32':
      return 'Cypress.exe';
    // TODO handle this error using our standard
    default:
      throw new Error(`Platform: "${platform}" is not supported.`);
  }
};
const getPlatFormBinaryFolder = () => {
  const platform = os.platform();
  switch (platform) {
    case 'darwin':
      return 'Cypress.app';
    case 'linux':
      return 'Cypress';
    case 'win32':
      return 'Cypress';
    // TODO handle this error using our standard
    default:
      throw new Error(`Platform: "${platform}" is not supported.`);
  }
};
const getBinaryPkgPath = binaryDir => {
  const platform = os.platform();
  switch (platform) {
    case 'darwin':
      return path.join(binaryDir, 'Contents', 'Resources', 'app', 'package.json');
    case 'linux':
      return path.join(binaryDir, 'resources', 'app', 'package.json');
    case 'win32':
      return path.join(binaryDir, 'resources', 'app', 'package.json');
    // TODO handle this error using our standard
=======

const os = require('os');

const path = require('path');

const untildify = require('untildify');

const debug = require('debug')('cypress:cli');

const fs = require('../fs');

const util = require('../util');

const getPlatformExecutable = () => {
  const platform = os.platform();

  switch (platform) {
    case 'darwin':
      return 'Contents/MacOS/Cypress';

    case 'linux':
      return 'Cypress';

    case 'win32':
      return 'Cypress.exe';
    // TODO handle this error using our standard

>>>>>>> branch-teste-codigo
    default:
      throw new Error(`Platform: "${platform}" is not supported.`);
  }
};

<<<<<<< HEAD
/**
 * Get path to binary directory
*/
const getBinaryDir = (version = util.pkgVersion()) => {
  return path.join(getVersionDir(version), getPlatFormBinaryFolder());
};
=======
const getPlatFormBinaryFolder = () => {
  const platform = os.platform();

  switch (platform) {
    case 'darwin':
      return 'Cypress.app';

    case 'linux':
      return 'Cypress';

    case 'win32':
      return 'Cypress';
    // TODO handle this error using our standard

    default:
      throw new Error(`Platform: "${platform}" is not supported.`);
  }
};

const getBinaryPkgPath = binaryDir => {
  const platform = os.platform();

  switch (platform) {
    case 'darwin':
      return path.join(binaryDir, 'Contents', 'Resources', 'app', 'package.json');

    case 'linux':
      return path.join(binaryDir, 'resources', 'app', 'package.json');

    case 'win32':
      return path.join(binaryDir, 'resources', 'app', 'package.json');
    // TODO handle this error using our standard

    default:
      throw new Error(`Platform: "${platform}" is not supported.`);
  }
};
/**
 * Get path to binary directory
*/


const getBinaryDir = (version = util.pkgVersion()) => {
  return path.join(getVersionDir(version), getPlatFormBinaryFolder());
};

>>>>>>> branch-teste-codigo
const getVersionDir = (version = util.pkgVersion(), buildInfo = util.pkgBuildInfo()) => {
  if (buildInfo && !buildInfo.stable) {
    version = ['beta', version, buildInfo.commitBranch, buildInfo.commitSha.slice(0, 8)].join('-');
  }
<<<<<<< HEAD
  return path.join(getCacheDir(), version);
};

=======

  return path.join(getCacheDir(), version);
};
>>>>>>> branch-teste-codigo
/**
 * When executing "npm postinstall" hook, the working directory is set to
 * "<current folder>/node_modules/cypress", which can be surprising when using relative paths.
 */
<<<<<<< HEAD
=======


>>>>>>> branch-teste-codigo
const isInstallingFromPostinstallHook = () => {
  // individual folders
  const cwdFolders = process.cwd().split(path.sep);
  const length = cwdFolders.length;
  return cwdFolders[length - 2] === 'node_modules' && cwdFolders[length - 1] === 'cypress';
};
<<<<<<< HEAD
const getCacheDir = () => {
  let cache_directory = util.getCacheDir();
  if (util.getEnv('CYPRESS_CACHE_FOLDER')) {
    const envVarCacheDir = untildify(util.getEnv('CYPRESS_CACHE_FOLDER'));
    debug('using environment variable CYPRESS_CACHE_FOLDER %s', envVarCacheDir);
=======

const getCacheDir = () => {
  let cache_directory = util.getCacheDir();

  if (util.getEnv('CYPRESS_CACHE_FOLDER')) {
    const envVarCacheDir = untildify(util.getEnv('CYPRESS_CACHE_FOLDER'));
    debug('using environment variable CYPRESS_CACHE_FOLDER %s', envVarCacheDir);

>>>>>>> branch-teste-codigo
    if (!path.isAbsolute(envVarCacheDir) && isInstallingFromPostinstallHook()) {
      const packageRootFolder = path.join('..', '..', envVarCacheDir);
      cache_directory = path.resolve(packageRootFolder);
      debug('installing from postinstall hook, original root folder is %s', packageRootFolder);
      debug('and resolved cache directory is %s', cache_directory);
    } else {
      cache_directory = path.resolve(envVarCacheDir);
    }
  }
<<<<<<< HEAD
  return cache_directory;
};
const parseRealPlatformBinaryFolderAsync = binaryPath => {
  return fs.realpathAsync(binaryPath).then(realPath => {
    debug('CYPRESS_RUN_BINARY has realpath:', realPath);
    if (!realPath.toString().endsWith(getPlatformExecutable())) {
      return false;
    }
    if (os.platform() === 'darwin') {
      return path.resolve(realPath, '..', '..', '..');
    }
    return path.resolve(realPath, '..');
  });
};
const getDistDir = () => {
  return path.join(__dirname, '..', '..', 'dist');
};

=======

  return cache_directory;
};

const parseRealPlatformBinaryFolderAsync = binaryPath => {
  return fs.realpathAsync(binaryPath).then(realPath => {
    debug('CYPRESS_RUN_BINARY has realpath:', realPath);

    if (!realPath.toString().endsWith(getPlatformExecutable())) {
      return false;
    }

    if (os.platform() === 'darwin') {
      return path.resolve(realPath, '..', '..', '..');
    }

    return path.resolve(realPath, '..');
  });
};

const getDistDir = () => {
  return path.join(__dirname, '..', '..', 'dist');
};
>>>>>>> branch-teste-codigo
/**
 * Returns full filename to the file that keeps the Test Runner verification state as JSON text.
 * Note: the binary state file will be stored one level up from the given binary folder.
 * @param {string} binaryDir - full path to the folder holding the binary.
 */
<<<<<<< HEAD
const getBinaryStatePath = binaryDir => {
  return path.join(binaryDir, '..', 'binary_state.json');
};
=======


const getBinaryStatePath = binaryDir => {
  return path.join(binaryDir, '..', 'binary_state.json');
};

>>>>>>> branch-teste-codigo
const getBinaryStateContentsAsync = binaryDir => {
  const fullPath = getBinaryStatePath(binaryDir);
  return fs.readJsonAsync(fullPath).catch({
    code: 'ENOENT'
  }, SyntaxError, () => {
    debug('could not read binary_state.json file at "%s"', fullPath);
    return {};
  });
};
<<<<<<< HEAD
const getBinaryVerifiedAsync = binaryDir => {
  return getBinaryStateContentsAsync(binaryDir).tap(debug).get('verified');
};
const clearBinaryStateAsync = binaryDir => {
  return fs.removeAsync(getBinaryStatePath(binaryDir));
};

=======

const getBinaryVerifiedAsync = binaryDir => {
  return getBinaryStateContentsAsync(binaryDir).tap(debug).get('verified');
};

const clearBinaryStateAsync = binaryDir => {
  return fs.removeAsync(getBinaryStatePath(binaryDir));
};
>>>>>>> branch-teste-codigo
/**
 * Writes the new binary status.
 * @param {boolean} verified The new test runner state after smoke test
 * @param {string} binaryDir Folder holding the binary
 * @returns {Promise<void>} returns a promise
 */
<<<<<<< HEAD
=======


>>>>>>> branch-teste-codigo
const writeBinaryVerifiedAsync = (verified, binaryDir) => {
  return getBinaryStateContentsAsync(binaryDir).then(contents => {
    return fs.outputJsonAsync(getBinaryStatePath(binaryDir), _.extend(contents, {
      verified
    }), {
      spaces: 2
    });
  });
};
<<<<<<< HEAD
const getPathToExecutable = binaryDir => {
  return path.join(binaryDir, getPlatformExecutable());
};

=======

const getPathToExecutable = binaryDir => {
  return path.join(binaryDir, getPlatformExecutable());
};
>>>>>>> branch-teste-codigo
/**
 * Resolves with an object read from the binary app package.json file.
 * If the file does not exist resolves with null
 */
<<<<<<< HEAD
=======


>>>>>>> branch-teste-codigo
const getBinaryPkgAsync = binaryDir => {
  const pathToPackageJson = getBinaryPkgPath(binaryDir);
  debug('Reading binary package.json from:', pathToPackageJson);
  return fs.pathExistsAsync(pathToPackageJson).then(exists => {
    if (!exists) {
      return null;
    }
<<<<<<< HEAD
    return fs.readJsonAsync(pathToPackageJson);
  });
};
const getBinaryPkgVersion = o => _.get(o, 'version', null);
const getBinaryElectronVersion = o => _.get(o, 'electronVersion', null);
const getBinaryElectronNodeVersion = o => _.get(o, 'electronNodeVersion', null);
=======

    return fs.readJsonAsync(pathToPackageJson);
  });
};

const getBinaryPkgVersion = o => _.get(o, 'version', null);

const getBinaryElectronVersion = o => _.get(o, 'electronVersion', null);

const getBinaryElectronNodeVersion = o => _.get(o, 'electronNodeVersion', null);

>>>>>>> branch-teste-codigo
module.exports = {
  getPathToExecutable,
  getPlatformExecutable,
  // those names start to sound like Java
  getBinaryElectronNodeVersion,
  getBinaryElectronVersion,
  getBinaryPkgVersion,
  getBinaryVerifiedAsync,
  getBinaryPkgAsync,
  getBinaryPkgPath,
  getBinaryDir,
  getCacheDir,
  clearBinaryStateAsync,
  writeBinaryVerifiedAsync,
  parseRealPlatformBinaryFolderAsync,
  getDistDir,
  getVersionDir
};